/*
 * cvt.c
 *
 *  Created on: 22 џэт. 2016 у.
 *      Author: complynx
 */

#include "espmissingincludes.h"
#include "ets_sys.h"
#include "osapi.h"
#include "dtoa.h"
#include "user_config.h"
#include "driver/uart.h"
#include "osbean.h"

#define TESTFLAG(x) 0

//extern double modf(double, double *);
#define to_char(n)  ((n) + '0')
#define to_digit(c) ((c) - '0')

#ifdef MYMODF
ICACHE_FLASH_ATTR double _l_modf(double __x, double *__i)
{
	*__i=3.;
//	char*p=(char*)(&__x);
//	u64* d=(u64*)&__x;
//	ets_uart_printf("%x %x %x %x %x %x %x %x ",p[0],p[1],p[2],p[3],p[4],p[5],p[6],p[7]);
//	ets_uart_printf("test ");
//	*__i=floor(__x);

//	DPRINT("%lx %lx %lx %lx",(u32)D_SGN(__x),(u32)D_EXP(__x),(u32)D_MANH(__x),(u32)D_MANL(__x));
	PM;
	return __x-(*__i);
//        double_t * x = (double_t *)&__x;
//        double_t * iptr = ( double_t *)__i;
//
//        int j0;
//        unsigned int i;
//        j0 = x->exponent - 0x3ff;  /* exponent of x */
//        if(j0<20) {                     /* integer part in high x */
//                if(j0<0) {                  /* |x|<1 */
//                        *__i = 0.0;
//                        iptr->sign = x->sign;
//                        return __x;
//                } else {
//
//                        if ( x->mantissah == 0 && x->mantissal == 0 ) {
//                                *__i = __x;
//                                return 0.0;
//                        }
//
//                        i = (0x000fffff)>>j0;
//                        iptr->sign = x->sign;
//                        iptr->exponent = x->exponent;
//                        iptr->mantissah = x->mantissah&(~i);
//                        iptr->mantissal = 0;
//                        if ( __x == *__i ) {
//                                __x = 0.0;
//                                x->sign = iptr->sign;
//                                return __x;
//                        }
//                        return __x - *__i;
//                }
//        } else if (j0>51) {             /* no fraction part */
//                *__i = __x;
//                if ( _isNan(__x) || _isinf(__x) )
//                        return __x;
//
//                __x = 0.0;
//                x->sign = iptr->sign;
//                return __x;
//        } else {                        /* fraction part in low x */
//
//                i = ((unsigned)(0xffffffff))>>(j0-20);
//                iptr->sign = x->sign;
//                iptr->exponent = x->exponent;
//                iptr->mantissah = x->mantissah;
//                iptr->mantissal = x->mantissal&(~i);
//                if ( __x == *__i ) {
//                        __x = 0.0;
//                        x->sign = iptr->sign;
//                        return __x;
//                }
//                return __x - *__i;
//        }
}
#endif

static ICACHE_FLASH_ATTR int _finite(double d)
{
    return !_isinf(d);
}

static ICACHE_FLASH_ATTR char *
exponent(char *p, int exp, int fmtch)
{
    char *t;
    char *expbuf=os_malloc(MAX_FCONVERSION);

    *p++ = fmtch;
    if (exp < 0) {
        exp = -exp;
        *p++ = '-';
    }
    else
        *p++ = '+';
    t = expbuf + MAX_FCONVERSION;
    if (exp > 9) {
        do {
            *--t = to_char(exp % 10);
        } while ((exp /= 10) > 9);
        *--t = to_char(exp);
        for (; t < expbuf + MAX_FCONVERSION; *p++ = *t++);
    }
    else {
        *p++ = '0';
        *p++ = to_char(exp);
    }
    os_free(expbuf);
    return (p);
}

static ICACHE_FLASH_ATTR char *
c_round(double fract, int *exp, char *start, char *end, char ch, char *signp)
{
    double tmp;

    if (fract)
        (void)_l_modf(fract * 10, &tmp);
    else
        tmp = to_digit(ch);
    if (tmp > 4)
        for (;; --end) {
            if (*end == '.')
                --end;
            if (++*end <= '9')
                break;
            *end = '0';
            if (end == start) {
                if (exp) {  /* e/E; increment exponent */
                    *end = '1';
                    ++*exp;
                }
                else {      /* f; add extra digit */
                *--end = '1';
                --start;
                }
                break;
            }
        }
    /* ``"%.3f", (double)-0.0004'' gives you a negative 0. */
    else if (*signp == '-')
        for (;; --end) {
            if (*end == '.')
                --end;
            if (*end != '0')
                break;
            if (end == start)
                *signp = 0;
        }
    return (start);
}

static ICACHE_FLASH_ATTR int
cvt(double number, int prec, char *signp, int fmtch, char *startp, char *endp)
{
    register char *p, *t;
    register double fract;
    double integer, tmp;
    int dotrim, expcnt, gformat;

    dotrim = expcnt = gformat = 0;
    if (number < 0) {
        number = -number;
        *signp = '-';
    } else
        *signp = 0;
    PM;

    fract = _l_modf(number, &integer);
    PM;

    /* get an extra slot for rounding. */
    t = ++startp;

    /*
     * get integer portion of number; put into the end of the buffer; the
     * .01 is added for modf(356.0 / 10, &integer) returning .59999999...
     */
    for (p = endp - 1; integer; ++expcnt) {
        tmp = _l_modf(integer / 10, &integer);
        *p-- = to_char((int)((tmp + .01) * 10));
    }
    PM;
    switch (fmtch) {
    case 'f':
        /* reverse integer into beginning of buffer */
    	PM;
        if (expcnt)
            for (; ++p < endp; *t++ = *p);
        else
            *t++ = '0';
        /*
         * if precision required or alternate flag set, add in a
         * decimal point.
         */
        PM;
        if (prec || TESTFLAG(ALTERNATE_FORM))
            *t++ = '.';
        /* if requires more precision and some fraction left */
        if (fract) {
            if (prec)
                do {
                    fract = _l_modf(fract * 10, &tmp);
                    *t++ = to_char((int)tmp);
                } while (--prec && fract);
            if (fract)
                startp = c_round(fract, (int *)0, startp,
                    t - 1, (char)0, signp);
        }
        PM;
        for (; prec--; *t++ = '0');
        break;
    case 'e':
    case 'E':
eformat:    if (expcnt) {
            *t++ = *++p;
            if (prec || TESTFLAG(ALTERNATE_FORM))
                *t++ = '.';
            /* if requires more precision and some integer left */
            for (; prec && ++p < endp; --prec)
                *t++ = *p;
            /*
             * if done precision and more of the integer component,
             * round using it; adjust fract so we don't re-round
             * later.
             */
            if (!prec && ++p < endp) {
                fract = 0;
                startp = c_round((double)0, &expcnt, startp,
                    t - 1, *p, signp);
            }
            /* adjust expcnt for digit in front of decimal */
            --expcnt;
        }
        /* until first fractional digit, decrement exponent */
        else if (fract) {
            /* adjust expcnt for digit in front of decimal */
            for (expcnt = -1;; --expcnt) {
                fract = _l_modf(fract * 10, &tmp);
                if (tmp)
                    break;
            }
            *t++ = to_char((int)tmp);
            if (prec || TESTFLAG(ALTERNATE_FORM))
                *t++ = '.';
        }
        else {
            *t++ = '0';
            if (prec || TESTFLAG(ALTERNATE_FORM))
                *t++ = '.';
        }
        /* if requires more precision and some fraction left */
        if (fract) {
            if (prec)
                do {
                    fract = _l_modf(fract * 10, &tmp);
                    *t++ = to_char((int)tmp);
                } while (--prec && fract);
            if (fract)
                startp = c_round(fract, &expcnt, startp,
                    t - 1, (char)0, signp);
        }
        /* if requires more precision */
        for (; prec--; *t++ = '0');

        /* unless alternate flag, trim any g/G format trailing 0's */
        if (gformat && !TESTFLAG(ALTERNATE_FORM)) {
            while (t > startp && *--t == '0');
            if (*t == '.')
                --t;
            ++t;
        }
        t = exponent(t, expcnt, fmtch);
        break;
    case 'g':
    case 'G':
        /* a precision of 0 is treated as a precision of 1. */
        if (!prec)
            ++prec;
        /*
         * ``The style used depends on the value converted; style e
         * will be used only if the exponent resulting from the
         * conversion is less than -4 or greater than the precision.''
         *  -- ANSI X3J11
         */
        if (expcnt > prec || (!expcnt && fract && fract < .0001)) {
            /*
             * g/G format counts "significant digits, not digits of
             * precision; for the e/E format, this just causes an
             * off-by-one problem, i.e. g/G considers the digit
             * before the decimal point significant and e/E doesn't
             * count it as precision.
             */
            --prec;
            fmtch -= 2;     /* G->E, g->e */
            gformat = 1;
            goto eformat;
        }
        /*
         * reverse integer into beginning of buffer,
         * note, decrement precision
         */
        if (expcnt)
            for (; ++p < endp; *t++ = *p, --prec);
        else
            *t++ = '0';
        /*
         * if precision required or alternate flag set, add in a
         * decimal point.  If no digits yet, add in leading 0.
         */
        if (prec || TESTFLAG(ALTERNATE_FORM)) {
            dotrim = 1;
            *t++ = '.';
        }
        else
            dotrim = 0;
        /* if requires more precision and some fraction left */
        if (fract) {
            if (prec) {
                    do {
                    fract = _l_modf(fract * 10, &tmp);
                    *t++ = to_char((int)tmp);
                } while(!tmp && !expcnt);
                while (--prec && fract) {
                    fract = _l_modf(fract * 10, &tmp);
                    *t++ = to_char((int)tmp);
                }
            }
            if (fract)
                startp = c_round(fract, (int *)0, startp,
                    t - 1, (char)0, signp);
        }
        /* alternate format, adds 0's for precision, else trim 0's */
        if (TESTFLAG(ALTERNATE_FORM))
            for (; prec--; *t++ = '0');
        else if (dotrim) {
            while (t > startp && *--t == '0');
            if (*t != '.')
                ++t;
        }
    }
    PM;
    return (t - startp);
}

void
ICACHE_FLASH_ATTR
dtoa (char *dbuf, double arg, int fmtch, int width, int prec)
{
    char    *buf, *cp;
    char    sign;
    int size;


    PM;
    if( _isinf(arg) ) {
        if( _isNan(arg) )
            os_strcpy (dbuf, "NaN");
        else if( arg < 0)
        	os_strcpy (dbuf, "-Infinity");
        else
        	os_strcpy (dbuf, "Infinity");
        return;
    }
    buf=os_malloc(MAX_FCONVERSION+1);

    PM;
    if (prec == 0)
        prec = 6;
    else if (prec > MAX_FRACT)
        prec = MAX_FRACT;

    /* leave room for sign at start of buffer */
    cp = buf + 1;

    /*
     * cvt may have to round up before the "start" of
     * its buffer, i.e. ``intf("%.2f", (double)9.999);'';
     * if the first character is still NUL, it did.
     * softsign avoids negative 0 if _double < 0 but
     * no significant digits will be shown.
     */
    *cp = '\0';
    PM;
    size = cvt (arg, prec, &sign, fmtch, cp, buf + sizeof(buf));
    if (*cp == '\0')
        cp++;

    if (sign)
        *--cp = sign, size++;

    cp[size] = 0;
    PM;
    os_memcpy (dbuf, cp, size + 1);
    os_free(buf);
}

